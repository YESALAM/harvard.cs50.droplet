{
  "mode": "c_cpp",
  "viewSettings": {
    "padding": 10,
    "textPadding": 5
  },
  "palette": [
    {
      "name": "Control",
      "color": "orange",
      "blocks": [
        {
          "block": "if (condition)\n{\n  \n}",
          "context": "blockItem",
          "title": "<p>if -- do something only if a test is true</p>\n<p>An <code>if</code> statement. Only executes the code inside <code>{ }</code>\nif the condition in the parentheses <code>( )</code> is      true. Add\nan <code>else</code> or <code>else if</code> using the arrow at the bottom, which\nwill run if the statement isn&#39;t true.</p>\n"
        },
        {
          "block": "if (condition)\n{\n  \n}\nelse\n{\n  \n}",
          "context": "blockItem",
          "title": "<p>if -- do something only if a test is true</p>\n<p>An <code>if</code> statement. Only executes the code inside <code>{ }</code>\nif the condition in the parentheses <code>( )</code> is      true. Add\nan <code>else</code> or <code>else if</code> using the arrow at the bottom, which\nwill run if the statement isn&#39;t true.</p>\n"
        },
        {
          "block": "if (condition1)\n{\n  \n}\nelse if (condition2)\n{\n  \n}\nelse\n{\n  \n}",
          "context": "blockItem",
          "title": "<p>if -- do something only if a test is true</p>\n<p>An <code>if</code> statement. Only executes the code inside <code>{ }</code>\nif the condition in the parentheses <code>( )</code> is      true. Add\nan <code>else</code> or <code>else if</code> using the arrow at the bottom, which\nwill run if the statement isn&#39;t true.</p>\n"
        },
        {
          "block": "while (condition)\n{\n  \n}",
          "context": "blockItem",
          "title": "<p>while -- do something repeatedly</p>\n<p>Repeatedly executes the code inside <code>{ }</code> until the condition\ninside the parentheses <code>( )</code> is false.</p>\n"
        },
        {
          "block": "for (type variable = init; condition; update)\n{\n  \n}",
          "context": "blockItem",
          "title": "<p>for -- iterate over a range</p>\n<p>Repeats the code inside <code>{ }</code> <code>n</code> times. It does this by\nmaking a variable <code>i</code> which increases every repeition until   it reaches\n<code>n</code>. You can use <code>i</code> inside the code to tell how many times the loop\nhas already run.</p>\n"
        },
        {
          "block": "break;",
          "context": "blockItem",
          "title": "<p>Break out of a loop before it finishes.</p>\n"
        },
        {
            "block": "switch (variable)\n{\n  case 1:\n    break;\n}",
            "context": "blockItem",
            "title": "<p>switch -- do different things based on value</p>\n<p>Jumps to the case corresponding to the value of <code>variable</code>. Remember to put <code>break</code> at the end of each case; otherwise more cases will run than you think!</p>"
        },
        {
            "block": "switch (variable)\n{\n  case 1:\n    break;\n  default:\n   break;\n}",
            "context": "blockItem",
            "title": "<p>switch -- do different things based on value</p>\n<p>Jumps to the case corresponding to the value of <code>variable</code>. If none of the cases fit, jumps to <code>default</code> instead.</p>"
        }
      ]
    },
    {
      "name": "Operations",
      "color": "green",
      "blocks": [
        {
          "block": "a + b",
          "context": "expression",
          "title": "add two numbers"
        },
        {
          "block": "a - b",
          "context": "expression",
          "title": "subtract two numbers"
        },
        {
          "block": "a * b",
          "context": "expression",
          "title": "multiply two numbers"
        },
        {
          "block": "a / b",
          "context": "expression",
          "title": "<p>divide two numbers</p>\n<p>Divide two numbers. Remember that if you\ndivide two integers, you will get an integer\nanswer that is rounded down.</p>\n"
        },
        {
          "block": "a % b",
          "context": "expression",
          "title": "<p>modulo</p>\n<p>Take the modulo of two numbers. This is the remainder\nwhen you divide <code>a</code> by <code>b</code>.</p>\n"
        },
        {
          "block": "a == b",
          "context": "expression",
          "title": "test if two numbers are equal"
        },
        {
          "block": "a != b",
          "context": "expression",
          "title": "test if two numbers are not equal"
        },
        {
          "block": "a < b",
          "context": "expression",
          "title": "<p>compare two numbers</p>\n<p>Test if <code>a</code> &lt; <code>b</code>.</p>\n"
        },
        {
          "block": "a > b",
          "context": "expression",
          "title": "<p>compare two numbers</p>\n<p>Test if <code>a</code> &gt; <code>b</code>.</p>\n"
        },
        {
          "block": "a || b",
          "context": "expression",
          "title": "<p>logical or</p>\n<p>This will be true if the condition\nin <code>a</code> is true, the condition in <code>b</code> is true, or both.</p>\n"
        },
        {
          "block": "a && b",
          "context": "expression",
          "title": "<p>logical and</p>\n<p>This will be true only if the condition\nin <code>a</code> is true and the condition in <code>b</code> is true.</p>\n"
        },
        {
          "block": "!a",
          "context": "expression",
          "title": "<p>logical not</p>\n<p>This will be true if <code>a</code> is not true</p>\n"
        },
        {
          "block": "variable[i]",
          "context": "expression",
          "title": "<p>pointer/array access</p>\n<p>Access the <code>i</code>th element of the array <code>variable</code>, or the <code>i</code>th thing after the pointer <code>variable</code>. Remember that    indices start at <code>0</code>, not <code>1</code>!</p>\n"
        },
        {
          "block": "*pointer",
          "context": "expression",
          "title": "<p>dereference a pointer into a value</p>\n<p>Look up the value at the pointer <code>variable</code>. This is the same as doing <code>variable[0]</code>.</p>"
        },
        {
          "block": "&variable",
          "context": "expression",
          "title": "<p>get pointer to variable</p>\n<p>Get a pointer to a variable you have already declared as something else.</p>"
        },
        {
          "block": "sizeof(type)",
          "context": "expression",
          "title": "<p>get the size of a type -- (TODO WRITEME)</p>"
        }
      ]
    },
    {
      "name": "Data",
      "color": "droplet-palette-data",
      "blocks": [
        {
          "block": "type variable = 0;",
          "context": "blockItem",
          "title": "<p>declare a variable</p>\n<p>Declare a variable of type <code>type</code> and name <code>variable</code> with an\ninitial value of <code>0</code>.</p>\n"
        },
        {
          "block": "type *pointer = NULL;",
          "context": "blockItem",
          "title": "<p>declare a pointer</p>\n<p>Declare pointer to a a variable of type <code>type</code> and name <code>v</code> with an\ninitial value of <code>NULL</code>. Hint: a string is <code>char*</     code>.</p>\n"
        },
        {
          "block": "type array[length] = {0};",
          "context": "blockItem",
          "title": "<p>declare an array</p>\n<p>Declare an array of type <code>type</code> and size <code>len</code> with name <code>v</code>. Arrays and pointers work much the same, except that arrays do not    need to be allocated first, because they are automatically allocated when they are declared.</p>"
        },
        {
          "block": "variable = value;",
          "context": "blockItem",
          "title": "<p>reassign a variable</p>\n<p>Assign a new value <code>value</code> to the variable with name <code>variable</code>. You must\ndeclare your variable before you can do this.</p>\n"
        },
        {
          "block": "malloc(size)",
          "context": "expression",
          "title": "<p><a href=\"https://reference.cs50.net/stdlib.h/malloc\" target=\"_blank\">malloc</a> - allocate memory</p>\n<p>Allocate <code>size</code> bytes of memory. Unlike <code>calloc</code>, <code>malloc</code> will not pre-set all\nallocated memory to zero.</p>\n"
        },
        {
          "block": "calloc(length, sizeof(type))",
          "context": "expression",
          "title": "<p><a href=\"https://reference.cs50.net/stdlib.h/calloc\" target=\"_blank\">calloc</a> - allocate memory and set it to zero</p>\n<p><code>calloc</code> allocates the requested memory and sets it all to zero. So, it will\nallocate  <code>size</code> bytes <code>items</code> number of times. For example, if <code>size</code> is\n4 bytes, and <code>items</code> 10, then <code>calloc</code> will allocate a total of 40 bytes. \nThis differs from <code>malloc</code> which doesn&#39;t set the memory to zero.</p>\n"
        },
        {
          "block": "typedef struct\n{\n  type member;\n}\nname;",
          "context": "externalDeclaration",
          "title": "<p><code>struct</code> -- bundle together data</p>\n<p>A <code>struct</code> defines a package of data made up of a set of data fields. Each data field should be declared in the <code>{ }</   code> like a variable."
        },
        {
          "block": "struct_name.member_name",
          "context": "expression",
          "title": "<p>struct property access</p>\n<p>Extract one of the data fields packaged into a struct.</p>\n"
        },
        {
          "block": "type member;",
          "context": "structDeclaration",
          "title": "<p>declare struct data field</p>"
        }
      ]
    },
    {
      "name": "Functions",
      "color": "blue",
      "blocks": [
        {
          "block": "int main(void)\n{\n  \n}",
          "context": "externalDeclaration",
          "title": "<p><code>main</code> -- starting point for the program</p>\n<p>The <code>main</code> method. Code inside here <code>{ }</code>\nwill run when your program is run. You must\ninclude a main     method in order for your program executable\nto do anything when run.</p>\n"
        },
        {
          "block": "int main(int n, char *argv[])\n{\n  \n}",
          "context": "externalDeclaration",
          "title": "<p><code>main</code> -- starting point for the program</p>\n<p>The <code>main</code> method. Code inside here <code>{ }</code>\nwill run when your program is run. You must\ninclude a main     method in order for your program executable\nto do anything when run. This version knows how to accept command line arguments; there are <code>n</code> of them, stored in the variable <code>args</code>.</p>\n"
        },
        {
          "block": "type function(void)\n{\n  \n}",
          "context": "externalDeclaration",
          "title": "<p>method -- reusable procedure</p>\n<p>Defines a method accepting a <code>void</code> (no arguments) and returning\na <code>type</code>. The code inside <code>{ }</code> will not run at      first, but will run every time\nyou call <code>function(arguments...)</code>. Use a <code>return</code> statement inside the method\nto pass information back to whoever called it.</p>\n"
        },
        {
          "block": "function(argument);",
          "context": "blockItem",
          "title": "<p>A method call.</p>\n"
        },
        {
          "block": "atoi(str);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/stdlib.h/atoi\" target=\"_blank\">atoi</a> - convert a string to an integer</p>\n<p>Use to convert some string <code>str</code> to an integer.</p>\n"
        },
        {
          "block": "calloc(items, size);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/stdlib.h/calloc\" target=\"_blank\">calloc</a> - allocate memory and set it to zero</p>\n<p><code>calloc</code> allocates the requested memory and sets it all to zero. So, it will\nallocate  <code>size</code> bytes <code>items</code> number of times. For example, if <code>size</code> is\n4 bytes, and <code>items</code> 10, then <code>calloc</code> will allocate a total of 40 bytes. \nThis differs from <code>malloc</code> which doesn&#39;t set the memory to zero.</p>\n"
        },
        {
          "block": "ceil(x);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/math.h/ceil\" target=\"_blank\">ceil</a> - rounds up value</p>\n<p>Rounds <code>x</code> upward.</p>\n"
        },
        {
          "block": "drand48();",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/stdlib.h/drand48\" target=\"_blank\">drand48</a> - returns a pseudorandom integer using 48-bit integer arithmetic</p>\n<p>The function <code>drand48()</code> returns a pseudorandom non-negative double-precision floating-point value over the interval [0.0, 1.0).</p>\n"
        },
        {
          "block": "fclose(fp);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/stdio.h/fclose\" target=\"_blank\">fclose</a> - close an open file</p>\n<p>Closes the current file pointed to by file pointer <code>fp</code>.</p>\n"
        },
        {
          "block": "feof(fp);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/stdio.h/feof\" target=\"_blank\">feof</a> - checks whether pointer to file has reached the end of the file</p>\n<p>Checks whether pointer to file has reached the end of the file.</p>\n"
        },
        {
          "block": "fgetc(fp);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/stdio.h/fgetc\" target=\"_blank\">fgetc</a> - get the next character from a file</p>\n<p>Gets the next character from a file.</p>\n"
        },
        {
          "block": "fgets(s, i, fp);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/stdio.h/fgets\" target=\"_blank\">fgets</a> - get the next string from a file</p>\n<p><code>fgets</code> reads in, at most, <code>i</code> characters from file <code>fp</code>, storing them \ntemporarily in buffer <code>s</code>.</p>\n"
        },
        {
          "block": "floor(x);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/math.h/floor\" target=\"_blank\">floor</a> - rounds down value</p>\n<p>Rounds <code>x</code> down.</p>\n"
        },
        {
          "block": "fopen(filename, mode);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/stdio.h/fopen\" target=\"_blank\">fopen</a> - opens a file</p>\n<p><code>fopen</code> opens file <code>filename</code> in the specified <code>mode</code>. The <code>mode</code> can be a\nnumber of things, however, the most common are <code>r</code> for reading, <code>w</code> for\nwriting, and <code>a</code> for appending. It should be noted, if you are opening a file\nto read using <code>r</code> then that file MUST exist, otherwise <code>fopen</code> will return \n<code>NULL</code>, something you should check for. Writing with <code>w</code> will create an empty \nfile even if one of the same name already exists, so be careful! Appending \nwith <code>a</code> will append data to the end of an already present file, or create an \nempty file if <code>filename</code> doesn&#39;t exist.</p>\n"
        },
        {
          "block": "fprintf(fp, format);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/stdio.h/fprintf\" target=\"_blank\">fprintf</a> - print out a formatted string</p>\n<p>Used to print to a file in a specific, formatted fashion, <code>fprintf</code> prints\nto the file <code>fp</code> as the string <code>format</code> indicates.</p>\n"
        },
        {
          "block": "fputc(character, fp);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/stdio.h/fputc\" target=\"_blank\">fputc</a> - write a character to a file</p>\n<p>Used to write a single character to a file.</p>\n"
        },
        {
          "block": "fputs(s, fp);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/stdio.h/fputs\" target=\"_blank\">fputs</a> - write a string to a file</p>\n<p><code>fputs</code> is used to write a null terminated string <code>s</code> to file <code>fp</code>.</p>\n"
        },
        {
          "block": "fread(ptr, size, blocks, fp);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/stdio.h/fread\" target=\"_blank\">fread</a> - read from a file</p>\n<p><code>fread</code> reads in from file <code>fp</code> an element of <code>size</code> bytes <code>blocks</code> number of\ntimes. So, for example, if <code>size</code> is 50 and <code>blocks</code> 10, then <code>fread</code> will read\nin from <code>fp</code> 10 times, each time reading in 50 bytes (for a total of 500 bytes).\nOn each <code>fread</code>, it will store the bytes in a buffer pointer to by <code>ptr</code>.</p>\n"
        },
        {
          "block": "free(ptr);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/stdlib.h/free\" target=\"_blank\">free</a> - free dynamically allocated memory</p>\n<p>Free takes a pointer to a block of memory on the heap and frees it for future\nuse. Whenever you dynamically allocate memory with something like <code>calloc</code>, \n<code>malloc</code>,or <code>realloc</code>, you have to, when done with the memory, <code>free</code> it. \nOtherwise, you&#39;ll end up with memory leaks.</p>\n"
        },
        {
          "block": "fscanf(fp, format);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/stdio.h/fscanf\" target=\"_blank\">fscanf</a> - read in a formatted string</p>\n<p><code>fscanf</code> reads in from file <code>fp</code> input that matches <code>format</code>.</p>\n"
        },
        {
          "block": "fseek(fp, offset, from_where);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/stdio.h/fseek\" target=\"_blank\">fseek</a> - sets file position</p>\n<p>Use <code>fseek</code> when you want to change the offset of the file pointer <code>fp</code>.\nThis is an extremely useful tool. Normally, when reading in from a file, \nthe pointer continues in one direction, from the start of the file to the\nend. <code>fseek</code>, however, allows you to change the location of the file pointer. (<a href=\"https://reference.cs50.net/stdio.h/fseek\" target=\"_blank\">read more</a>)</p>\n"
        },
        {
          "block": "fwrite(ptr, size, blocks, fp);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/stdio.h/fwrite\" target=\"_blank\">fwrite</a> - write to a file</p>\n<p>Similar to <code>fread</code>, <code>fwrite</code> writes out to file <code>fp</code> an element of <code>size</code> bytes \n<code>blocks</code> number of times. So, for example, if <code>size</code> is 50 and <code>blocks</code> 10, then \n<code>fwrite</code> will write to <code>fp</code> 10 times, each time a &quot;chunk&quot; of 50 bytes (for a total \nof 500 bytes). On each <code>fwrite</code>, it will write from the buffer pointer to by <code>ptr</code>.</p>\n"
        },
        {
          "block": "get_char();",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/cs50.h/GetChar\" target=\"_blank\">GetChar</a> - returns a char from stdin</p>\n<p>Reads a line of text from standard input and returns the equivalent <code>char</code>; if text does not represent a <code>char</code>, user is \nprompted to retry. Leading and trailing whitespace is ignored. If line can&#39;t be read, returns <code>CHAR_MAX</code>.</p>\n"
        },
        {
          "block": "get_double();",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/cs50.h/GetDouble\" target=\"_blank\">GetDouble</a> - returns a double from stdin</p>\n<p>Reads a line of text from standard input and returns the equivalent <code>double</code> as precisely as possible; if text does not \nrepresent a <code>double</code>, user is prompted to retry. Leading and trailing whitespace is ignored. For simplicity, overflow \nand underflow are not detected. If line can&#39;t be read, returns <code>DBL_MAX</code>.</p>\n"
        },
        {
          "block": "get_float();",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/cs50.h/GetFloat\" target=\"_blank\">GetFloat</a> - returns a float from stdin</p>\n<p>Reads a line of text from standard input and returns the equivalent <code>float</code> as precisely as possible; if text does not \nrepresent a <code>float</code>, user is prompted to retry. Leading and trailing whitespace is ignored. For simplicity, overflow \nand underflow are not detected.  If line can&#39;t be read, returns <code>FLT_MAX</code>.</p>\n"
        },
        {
          "block": "get_int();",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/cs50.h/GetInt\" target=\"_blank\">GetInt</a> - returns an int from stdin</p>\n<p>Reads a line of text from standard input and returns it as an <code>int</code> in the range of [-2^31^ + 1, 2^31^ - 2], if possible; \nif text does not represent such an <code>int</code>, user is prompted to retry. Leading and trailing whitespace is ignored. For \nsimplicity, overflow is not detected. If line can&#39;t be read, returns <code>INT_MAX</code>.</p>\n"
        },
        {
          "block": "get_long_long();",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/cs50.h/GetLongLong\" target=\"_blank\">GetLongLong</a> - returns a long long from stdin</p>\n<p>Reads a line of text from standard input and returns an equivalent <code>long long</code> in the range [-2^63^ + 1, 2^63^ - 2], if \npossible; if text does not represent such a <code>long long</code>, user is prompted to retry. Leading and trailing whitespace is \nignored. For simplicity, overflow is not detected. If line can&#39;t be read, returns <code>LLONG_MAX</code>.</p>\n"
        },
        {
          "block": "get_string();",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/cs50.h/GetString\" target=\"_blank\">GetString</a> - returns a string from stdin</p>\n<p>Reads a line of text from standard input and returns it as a <code>string</code> (<code>char *</code>), sans trailing newline character. (Ergo, \nif user inputs only <code>&quot;\\n&quot;</code>, returns &quot;&quot; not <code>NULL</code>.)  Returns <code>NULL</code> upon error or no input whatsoever (i.e., just <code>EOF</code>). \nLeading and trailing whitespace is not ignored. Stores <code>string</code> on heap (via <code>malloc</code>); memory must be freed by caller to \navoid leak.</p>\n"
        },
        {
          "block": "isalnum(c);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/ctype.h/isalnum\" target=\"_blank\">isalnum</a> - checks if character is alphanumeric</p>\n<p>Checks if the given character is alphanumeric.</p>\n"
        },
        {
          "block": "isalpha(c);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/ctype.h/isalpha\" target=\"_blank\">isalpha</a> - checks if character is an alphabetic letter.</p>\n<p>Checks if the given character is an alphabetic letter.</p>\n"
        },
        {
          "block": "isblank(c);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/ctype.h/isblank\" target=\"_blank\">isblank</a> - checks if character is blank</p>\n<p>Checks if the given character is blank, which means either a space <code>&#39; &#39;</code> or a tab <code>&#39;\\t&#39;</code>.</p>\n"
        },
        {
          "block": "iscntrl(c);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/ctype.h/iscntrl\" target=\"_blank\">iscntrl</a> - checks if character is control</p>\n<p>Checks if the given character is a control character. A control character is a character that is not displayed on the screen when printed. This is the opposite of a printable character (see <code>isprint()</code>). (<a href=\"https://reference.cs50.net/ctype.h/iscntrl\" target=\"_blank\">read more</a>)</p>\n"
        },
        {
          "block": "isdigit(c);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/ctype.h/isdigit\" target=\"_blank\">isdigit</a> - checks if character is a digit</p>\n<p>Checks if the given character is a numeric digit. Note that, per the ASCII table, the character <code>&#39;5&#39;</code> and the integer <code>5</code> are different and only the first one constitutes a numeric digit. </p>\n"
        },
        {
          "block": "isgraph(c);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/ctype.h/isgraph\" target=\"_blank\">isgraph</a> - checks if character is graphical</p>\n<p>Checks if the given character has a graphical representation. The characters with graphical representation are all those given by <code>isprint()</code> except the space character <code>&#39; &#39;</code>.</p>\n"
        },
        {
          "block": "islower(c);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/ctype.h/islower\" target=\"_blank\">islower</a> - checks if character is lowercase</p>\n<p>Checks if the given character is a lowercase alphabetic letter.</p>\n"
        },
        {
          "block": "isprint(c);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/ctype.h/isprint\" target=\"_blank\">isprint</a> - checks if character is printable</p>\n<p>Checks if the given character is a printable character. A printable character is a character that is displayed on the screen when printed. This is the opposite of a control character (see <code>iscntrl()</code>). (<a href=\"https://reference.cs50.net/ctype.h/isprint\" target=\"_blank\">read more</a>)</p>\n"
        },
        {
          "block": "ispunct(c);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/ctype.h/ispunct\" target=\"_blank\">ispunct</a> - checks if character is a punctuation mark</p>\n<p>Checks if the given character is a punctuation character. C considers every graphic character (see <code>isgraph()</code>) that is not alphanumeric to be a punctuation.</p>\n"
        },
        {
          "block": "isspace(c);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/ctype.h/isspace\" target=\"_blank\">isspace</a> - checks if character is a white-space</p>\n<p>Checks if the given character is a white-space character. C considers white-space characters to be <code>&#39; &#39;</code>,<code>&#39;\\n&#39;</code>,<code>\\t</code>,<code>&#39;\\v&#39;</code>,<code>\\f</code>,<code>&#39;\\r&#39;</code>.</p>\n"
        },
        {
          "block": "isupper(c);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/ctype.h/isupper\" target=\"_blank\">isupper</a> - checks if character is uppercase</p>\n<p>Checks if the given character is an uppercase alphabetic letter.</p>\n"
        },
        {
          "block": "isxdigit(c);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/ctype.h/isxdigit\" target=\"_blank\">isxdigit</a> - checks if character is hexadecimal</p>\n<p>Checks if the given character is a hexadecimal digit. (<a href=\"https://reference.cs50.net/ctype.h/isxdigit\" target=\"_blank\">read more</a>)</p>\n"
        },
        {
          "block": "malloc(size);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/stdlib.h/malloc\" target=\"_blank\">malloc</a> - allocate memory</p>\n<p>Allocate <code>size</code> bytes of memory. Unlike <code>calloc</code>, <code>malloc</code> will not pre-set all\nallocated memory to zero.</p>\n"
        },
        {
          "block": "printf(format);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/stdio.h/printf\" target=\"_blank\">printf</a> - prints to stdout</p>\n<p><code>printf</code> prints some formatted output to <code>stdout</code> (your computer terminal).\nYou specify the format with a <code>%</code> followed by a <code>c</code> for a character, <code>d</code> for\na digit, and <code>s</code> for a string. There are a number of other identifiers, the\naformentioned, however, are the most used. (<a href=\"https://reference.cs50.net/stdio.h/printf\" target=\"_blank\">read more</a>)</p>\n"
        },
        {
          "block": "rand();",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/stdlib.h/rand\" target=\"_blank\">rand</a> - returns a pseudorandom integer</p>\n<p>The function rand() returns a pseudorandom integer between zero and RAND_MAX.</p>\n"
        },
        {
          "block": "realloc(ptr, size);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/stdlib.h/realloc\" target=\"_blank\">realloc</a> - reallocate memory previously allocated</p>\n<p>Reallocate memory that was previously allocated with <code>calloc</code> or <code>malloc</code>. You\ntake the memory block pointed to by <code>ptr</code> and give it a new <code>size</code>.</p>\n"
        },
        {
          "block": "round(x);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/math.h/round\" target=\"_blank\">round</a> - rounds value</p>\n<p>Rounds the <code>double</code> <code>x</code> to the nearest integer value.</p>\n"
        },
        {
          "block": "scanf(format);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/stdio.h/scanf\" target=\"_blank\">scanf</a> - read in a formatted string from stdin</p>\n<p><code>scanf</code> reads in from <code>stdin</code> (usually your keyboard) input that matches \n<code>format</code>. Notice, this function is almost identical to <code>fscanf</code> except it \nis missing the first argument <code>FILE* fp</code>. This is because <code>scanf</code> just assumes \nthe input is going to be coming from the keyboard. (<a href=\"https://reference.cs50.net/stdio.h/scanf\" target=\"_blank\">read more</a>)</p>\n"
        },
        {
          "block": "sprintf(ptr, format);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/stdio.h/sprintf\" target=\"_blank\">sprintf</a> - send formatted output to a string</p>\n<p><code>sprintf</code> stores in <code>ptr</code> a string formatted along the lines of <code>format</code>.</p>\n"
        },
        {
          "block": "srand(seed);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/stdlib.h/srand\" target=\"_blank\">srand</a> - seed the pseudorandom generator <code>rand</code></p>\n<p>The thing about the function <code>rand</code> is it will generate a &quot;random&quot; integer,\nhowever, if you seed it with the same number, you will get the same &quot;random&quot;\nsequence of numbers. Therefore, we want to seed <code>rand</code> with something that\nalways changes. Often, it makes sense to seed <code>rand</code> with <code>time</code>, as it\nis a variable that will always be changing. We seed the <code>rand</code> function with\n<code>srand</code>.</p>\n"
        },
        {
          "block": "srand48(seedval);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/stdlib.h/srand48\" target=\"_blank\">srand48</a> - seeds the pseudorandom generator drand48()</p>\n<p>The function <code>srand48()</code> is used to seed, or initialize, the internal buffer of functions such as <code>drand48()</code>. You normally seed <code>drand48()</code> with \nsomething like <code>time(NULL)</code> since this value will always change. If you were to simply call <code>drand48()</code> without seeding it, you&#39;d get the same string\nof &#39;random&#39; doubles back.</p>\n"
        },
        {
          "block": "strcmp(str1, str2);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/string.h/strcmp\" target=\"_blank\">strcmp</a> - compare two strings</p>\n<p><code>strcmp</code> compares two strings: <code>str1</code> and <code>str2</code>.</p>\n"
        },
        {
          "block": "strcpy(destination, source);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/string.h/strcpy\" target=\"_blank\">strcpy</a> - copy a string</p>\n<p><code>strcpy</code> copys string <code>source</code> into string <code>destination</code>.</p>\n"
        },
        {
          "block": "strlen(str);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/string.h/strlen\" target=\"_blank\">strlen</a> - return length of a string</p>\n<p>Return the length of a string.</p>\n"
        },
        {
          "block": "tolower(c);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/ctype.h/tolower\" target=\"_blank\">tolower</a> - converts letter to lowercase</p>\n<p>Converts an uppercase letter to lowercase.</p>\n"
        },
        {
          "block": "toupper(c);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/ctype.h/toupper\" target=\"_blank\">toupper</a> - converts letter to uppercase</p>\n<p>Converts a lowercase letter to uppercase.</p>\n"
        }
      ]
    },
    {
      "name": "Preprocessor",
      "color": "purple",
      "blocks": [
        {
          "block": "#include <header.h>",
          "context": "compilationUnit",
          "title": "<p><code>#include</code> -- include library files</p>\n<p>Put this at the top of your program to include the necessary files to use a library. Examples: <code>#include &lt;stdio.h&gt;</code> or <code>#include &lt;cs50.h&gt;</code></p>"
        },
        {
          "block": "#define MACRO_NAME macro_value",
          "context": "compilationUnit",
          "title": "<p><code>#define</code> -- define a macro</p>\n<p>Put this at the top of your program to define a macro. The compiler will go through your program and replace all instances of <code>MACRO_NAME</code> with the value. Most often, this is used for defining constants.</p>"
        }
      ]
    },
    {
      "name": "Comments",
      "color": "grey",
      "blocks": [
        {
          "block": "// comment",
          "context": "compilationUnit",
          "title": "<p>comment</p>\n<p>Add some text to explain part of your code. This block can go anywhere.</p>"
        }
      ]
    }
  ],
  "modeOptions": {
    "categories": {
        "value": "#94c096",
        "assign": "#f3a55d",
        "declaration": "#f3a55d",
        "type": "#f3a55d",
        "control": "#ecc35b",
        "function": "#b593e6",
        "functionCall": "#889ee3",
        "logic": "#6fc2eb",
        "struct": "#f58c4f",
        "return": "#b593e6"
    },
    "functions": {
      "GetChar": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "GetChar();"
      },
      "GetDouble": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "GetDouble();"
      },
      "GetFloat": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "GetFloat();"
      },
      "GetInt": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "GetInt();"
      },
      "GetLongLong": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "GetLongLong();"
      },
      "GetString": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "GetString();"
      },
      "clearerr": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "clearerr(stream);"
      },
      "fclose": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fclose(fp);"
      },
      "feof": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "feof(fp);"
      },
      "ferror": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "ferror(stream);"
      },
      "fflush": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fflush(stream);"
      },
      "fgetc": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fgetc(fp);"
      },
      "fgetpos": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fgetpos(stream, pos);"
      },
      "fgets": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fgets(s, i, fp);"
      },
      "fopen": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fopen(filename, mode);"
      },
      "fprintf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fprintf(fp, format);",
        "minArgs": 2
      },
      "fputc": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fputc(character, fp);"
      },
      "fputs": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fputs(s, fp);"
      },
      "fread": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fread(ptr, size, blocks, fp);"
      },
      "fscanf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fscanf(fp, format);",
        "minArgs": 2
      },
      "fseek": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fseek(fp, offset, from_where);"
      },
      "fsetpos": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fsetpos(stream, pos);"
      },
      "ftell": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "ftell(stream);"
      },
      "fwrite": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fwrite(ptr, size, blocks, fp);"
      },
      "getc": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "getc(stream);"
      },
      "getchar": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "getchar();"
      },
      "gets": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "gets(s);"
      },
      "perror": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "perror(s);"
      },
      "printf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "printf(format);",
        "minArgs": 1
      },
      "putc": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "putc(c, stream);"
      },
      "putchar": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "putchar(c);"
      },
      "puts": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "puts(s);"
      },
      "remove": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "remove(pathname);"
      },
      "rewind": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "rewind(stream);"
      },
      "scanf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "scanf(format);",
        "minArgs": 1
      },
      "setbuf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "setbuf(stream, buf);"
      },
      "setvbuf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "setvbuf(stream, buf, mode, size);"
      },
      "snprintf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "snprintf(str, size, format);",
        "minArgs": 3
      },
      "sprintf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "sprintf(ptr, format);",
        "minArgs": 2
      },
      "sscanf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "sscanf(str, format);",
        "minArgs": 2
      },
      "ungetc": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "ungetc(c, stream);"
      },
      "vfprintf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "vfprintf(stream, format, ap);"
      },
      "vfscanf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "vfscanf(stream, format, ap);"
      },
      "vprintf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "vprintf(format, ap);"
      },
      "vscanf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "vscanf(format, ap);"
      },
      "vsnprintf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "vsnprintf(str, size, format, ap);"
      },
      "vsprintf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "vsprintf(str, format, ap);"
      },
      "vsscanf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "vsscanf(str, format, ap);"
      },
      "abort": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "abort();"
      },
      "abs": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "abs(j);"
      },
      "atexit": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "atexit(function);"
      },
      "atof": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "atof(nptr);"
      },
      "atoi": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "atoi(str);"
      },
      "atol": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "atol(nptr);"
      },
      "atoll": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "atoll(nptr);"
      },
      "bsearch": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "bsearch(key, base, nmemb, size, compar);"
      },
      "calloc": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "calloc(items, size);"
      },
      "div": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "div(numerator, denominator);"
      },
      "drand48": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "drand48();"
      },
      "exit": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "exit(status);"
      },
      "free": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "free(ptr);"
      },
      "getenv": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "getenv(name);"
      },
      "labs": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "labs(j);"
      },
      "ldiv": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "ldiv(numerator, denominator);"
      },
      "llabs": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "llabs(j);"
      },
      "lldiv": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "lldiv(numerator, denominator);"
      },
      "malloc": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "malloc(size);"
      },
      "mblen": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "mblen(s, n);"
      },
      "mbstowcs": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "mbstowcs(dest, src, n);"
      },
      "mbtowc": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "mbtowc(pwc, s, n);"
      },
      "qsort": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "qsort(base, nmemb, size, compar);"
      },
      "rand": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "rand();"
      },
      "realloc": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "realloc(ptr, size);"
      },
      "srand": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "srand(seed);"
      },
      "srand48": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "srand48(seedval);"
      },
      "strtod": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strtod(nptr, endptr);"
      },
      "strtof": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strtof(nptr, endptr);"
      },
      "strtol": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strtol(nptr, endptr, base);"
      },
      "strtold": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strtold(nptr, endptr);"
      },
      "strtoll": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strtoll(nptr, endptr, base);"
      },
      "strtoul": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strtoul(nptr, endptr, base);"
      },
      "strtoull": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strtoull(nptr, endptr, base);"
      },
      "system": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "system(command);"
      },
      "wcstombs": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "wcstombs(dest, src, n);"
      },
      "wctomb": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "wctomb(s, wc);"
      },
      "memchr": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "memchr(s, c, n);"
      },
      "memcmp": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "memcmp(s1, s2, n);"
      },
      "memcpy": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "memcpy(dest, src, n);"
      },
      "memmove": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "memmove(dest, src, n);"
      },
      "memset": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "memset(s, c, n);"
      },
      "strcat": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strcat(dest, src);"
      },
      "strchr": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strchr(s, c);"
      },
      "strcmp": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strcmp(str1, str2);"
      },
      "strcoll": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strcoll(s1, s2);"
      },
      "strcpy": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strcpy(destination, source);"
      },
      "strcspn": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strcspn(s, reject);"
      },
      "strerror": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strerror(errnum);"
      },
      "strlen": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strlen(str);"
      },
      "strncat": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strncat(dest, src, n);"
      },
      "strncmp": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strncmp(s1, s2, n);"
      },
      "strncpy": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strncpy(dest, src, n);"
      },
      "strpbrk": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strpbrk(s, accept);"
      },
      "strrchr": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strrchr(s, c);"
      },
      "strspn": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strspn(s, accept);"
      },
      "strstr": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strstr(haystack, needle);"
      },
      "strtok": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strtok(str, delim);"
      },
      "strxfrm": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strxfrm(dest, src, n);"
      },
      "acos": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "acos(x);"
      },
      "acosh": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "acosh(x);"
      },
      "asin": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "asin(x);"
      },
      "asinh": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "asinh(x);"
      },
      "atan": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "atan(x);"
      },
      "atan2": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "atan2(y, x);"
      },
      "atanh": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "atanh(x);"
      },
      "ceil": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "ceil(x);"
      },
      "copysign": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "copysign(x, y);"
      },
      "cos": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "cos(x);"
      },
      "cosh": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "cosh(x);"
      },
      "erf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "erf(x);"
      },
      "erfc": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "erfc(x);"
      },
      "exp": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "exp(x);"
      },
      "exp2": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "exp2(x);"
      },
      "expm1": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "expm1(x);"
      },
      "fabs": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fabs(x);"
      },
      "fdim": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fdim(x, y);"
      },
      "floor": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "floor(x);"
      },
      "fma": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fma(x, y, z);"
      },
      "fmax": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fmax(x, y);"
      },
      "fmin": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fmin(x, y);"
      },
      "fmod": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fmod(x, y);"
      },
      "fpclassify": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fpclassify(x);"
      },
      "frexp": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "frexp(x, exp);"
      },
      "ilogb": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "ilogb(x);"
      },
      "isfinite": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isfinite(x);"
      },
      "isgreater": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isgreater(x, y);"
      },
      "isgreaterequal": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isgreaterequal(x, y);"
      },
      "isinf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isinf(x);"
      },
      "isless": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isless(x, y);"
      },
      "islessequal": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "islessequal(x, y);"
      },
      "islessgreater": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "islessgreater(x, y);"
      },
      "isnan": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isnan(x);"
      },
      "isnormal": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isnormal(x);"
      },
      "isunordered": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isunordered(x, y);"
      },
      "ldexp": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "ldexp(x, exp);"
      },
      "llrint": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "llrint(x);"
      },
      "llround": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "llround(x);"
      },
      "log": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "log(x);"
      },
      "log10": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "log10(x);"
      },
      "log1p": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "log1p(x);"
      },
      "log2": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "log2(x);"
      },
      "logb": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "logb(x);"
      },
      "lrint": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "lrint(x);"
      },
      "lround": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "lround(x);"
      },
      "modf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "modf(x, iptr);"
      },
      "nearbyint": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "nearbyint(x);"
      },
      "pow": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "pow(x, y);"
      },
      "remainder": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "remainder(x, y);"
      },
      "remquo": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "remquo(x, y, quo);"
      },
      "rint": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "rint(x);"
      },
      "round": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "round(x);"
      },
      "scalbln": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "scalbln(x, exp);"
      },
      "scalbn": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "scalbn(x, exp);"
      },
      "signbit": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "signbit(x);"
      },
      "sin": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "sin(x);"
      },
      "sinh": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "sinh(x);"
      },
      "sqrt": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "sqrt(x);"
      },
      "tan": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "tan(x);"
      },
      "tgamma": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "tgamma(x);"
      },
      "trunc": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "trunc(x);"
      },
      "asctime": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "asctime(tm);"
      },
      "clock": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "clock();"
      },
      "ctime": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "ctime(timep);"
      },
      "difftime": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "difftime(time1, time0);"
      },
      "mktime": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "mktime(tm);"
      },
      "strftime": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strftime(s, max, format, tm);"
      },
      "time": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "time(tloc);"
      },
      "isalnum": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isalnum(c);"
      },
      "isalpha": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isalpha(c);"
      },
      "isblank": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isblank(c);"
      },
      "iscntrl": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "iscntrl(c);"
      },
      "isdigit": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isdigit(c);"
      },
      "isgraph": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isgraph(c);"
      },
      "islower": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "islower(c);"
      },
      "isprint": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isprint(c);"
      },
      "ispunct": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "ispunct(c);"
      },
      "isspace": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isspace(c);"
      },
      "isupper": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isupper(c);"
      },
      "isxdigit": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isxdigit(c);"
      },
      "tolower": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "tolower(c);"
      },
      "toupper": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "toupper(c);"
      },
      "va_arg": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "va_arg(ap, type);"
      },
      "va_copy": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "va_copy(dest, src);"
      },
      "va_end": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "va_end(ap);"
      },
      "va_start": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "va_start(ap, last);"
      }
    }
  }
}
