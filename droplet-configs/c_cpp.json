{
  "mode": "c_cpp",
  "viewSettings": {
    "padding": 10,
    "textPadding": 5,
    "colors": {
        "value": "#94c096",
        "assign": "#f3a55d",
        "declaration": "#f3a55d",
        "type": "#f3a55d",
        "control": "#ecc35b",
        "function": "#b593e6",
        "functionCall": "#889ee3",
        "logic": "#6fc2eb",
        "struct": "#f58c4f",
        "return": "#b593e6"
    }
  },
  "palette": [
    {
      "name": "Control",
      "color": "orange",
      "blocks": [
        {
          "block": "if (condition)\n{\n  \n}",
          "context": "blockItem",
          "title": "<p>if -- do something only if a test is true</p>\n<p>An <code>if</code> statement. Only executes the code inside <code>{ }</code>\nif the condition in the parentheses <code>( )</code> is      true. Add\nan <code>else</code> or <code>else if</code> using the arrow at the bottom, which\nwill run if the statement isn&#39;t true.</p>\n"
        },
        {
          "block": "if (condition)\n{\n  \n}\nelse\n{\n  \n}",
          "context": "blockItem",
          "title": "<p>if -- do something only if a test is true</p>\n<p>An <code>if</code> statement. Only executes the code inside <code>{ }</code>\nif the condition in the parentheses <code>( )</code> is      true. Add\nan <code>else</code> or <code>else if</code> using the arrow at the bottom, which\nwill run if the statement isn&#39;t true.</p>\n"
        },
        {
          "block": "if (condition1)\n{\n  \n}\nelse if (condition2)\n{\n  \n}\nelse\n{\n  \n}",
          "context": "blockItem",
          "title": "<p>if -- do something only if a test is true</p>\n<p>An <code>if</code> statement. Only executes the code inside <code>{ }</code>\nif the condition in the parentheses <code>( )</code> is      true. Add\nan <code>else</code> or <code>else if</code> using the arrow at the bottom, which\nwill run if the statement isn&#39;t true.</p>\n"
        },
        {
          "block": "while (condition)\n{\n  \n}",
          "context": "blockItem",
          "title": "<p>while -- do something repeatedly</p>\n<p>Repeatedly executes the code inside <code>{ }</code> until the condition\ninside the parentheses <code>( )</code> is false.</p>\n"
        },
        {
          "block": "for (type variable = init; condition; update)\n{\n  \n}",
          "context": "blockItem",
          "title": "<p>for -- iterate over a range</p>\n<p>Repeats the code inside <code>{ }</code> <code>n</code> times. It does this by\nmaking a variable <code>i</code> which increases every repeition until   it reaches\n<code>n</code>. You can use <code>i</code> inside the code to tell how many times the loop\nhas already run.</p>\n"
        },
        {
          "block": "break;",
          "context": "blockItem",
          "title": "<p>Break out of a loop before it finishes.</p>\n"
        },
        {
            "block": "switch (variable)\n{\n  case 1:\n    break;\n}",
            "context": "blockItem",
            "title": "<p>switch -- do different things based on value</p>\n<p>Jumps to the case corresponding to the value of <code>variable</code>. Remember to put <code>break</code> at the end of each case; otherwise more cases will run than you think!</p>"
        },
        {
            "block": "switch (variable)\n{\n  case 1:\n    break;\n  default:\n   break;\n}",
            "context": "blockItem",
            "title": "<p>switch -- do different things based on value</p>\n<p>Jumps to the case corresponding to the value of <code>variable</code>. If none of the cases fit, jumps to <code>default</code> instead.</p>"
        }
      ]
    },
    {
      "name": "Operations",
      "color": "green",
      "blocks": [
        {
          "block": "a + b",
          "context": "expression",
          "title": "add two numbers"
        },
        {
          "block": "a - b",
          "context": "expression",
          "title": "subtract two numbers"
        },
        {
          "block": "a * b",
          "context": "expression",
          "title": "multiply two numbers"
        },
        {
          "block": "a / b",
          "context": "expression",
          "title": "<p>divide two numbers</p>\n<p>Divide two numbers. Remember that if you\ndivide two integers, you will get an integer\nanswer that is rounded down.</p>\n"
        },
        {
          "block": "a % b",
          "context": "expression",
          "title": "<p>modulo</p>\n<p>Take the modulo of two numbers. This is the remainder\nwhen you divide <code>a</code> by <code>b</code>.</p>\n"
        },
        {
          "block": "a == b",
          "context": "expression",
          "title": "test if two numbers are equal"
        },
        {
          "block": "a != b",
          "context": "expression",
          "title": "test if two numbers are not equal"
        },
        {
          "block": "a < b",
          "context": "expression",
          "title": "<p>compare two numbers</p>\n<p>Test if <code>a</code> &lt; <code>b</code>.</p>\n"
        },
        {
          "block": "a > b",
          "context": "expression",
          "title": "<p>compare two numbers</p>\n<p>Test if <code>a</code> &gt; <code>b</code>.</p>\n"
        },
        {
          "block": "a || b",
          "context": "expression",
          "title": "<p>logical or</p>\n<p>This will be true if the condition\nin <code>a</code> is true, the condition in <code>b</code> is true, or both.</p>\n"
        },
        {
          "block": "a && b",
          "context": "expression",
          "title": "<p>logical and</p>\n<p>This will be true only if the condition\nin <code>a</code> is true and the condition in <code>b</code> is true.</p>\n"
        },
        {
          "block": "!a",
          "context": "expression",
          "title": "<p>logical not</p>\n<p>This will be true if <code>a</code> is not true</p>\n"
        },
        {
          "block": "variable[i]",
          "context": "expression",
          "title": "<p>pointer/array access</p>\n<p>Access the <code>i</code>th element of the array <code>variable</code>, or the <code>i</code>th thing after the pointer <code>variable</code>. Remember that    indices start at <code>0</code>, not <code>1</code>!</p>\n"
        },
        {
          "block": "*pointer",
          "context": "expression",
          "title": "<p>dereference a pointer into a value</p>\n<p>Look up the value at the pointer <code>variable</code>. This is the same as doing <code>variable[0]</code>.</p>"
        },
        {
          "block": "&variable",
          "context": "expression",
          "title": "<p>get pointer to variable</p>\n<p>Get a pointer to a variable you have already declared as something else.</p>"
        },
        {
          "block": "sizeof(type)",
          "context": "expression",
          "title": "<p>sizeof</p>\n<p>Get the size of a type in bytes. Most commonly used in <code>malloc(sizeof(type))</code> to allocate memory for a pointer to a specific type.</p>"
        }
      ]
    },
    {
      "name": "Data",
      "color": "droplet-palette-data",
      "blocks": [
        {
          "block": "type variable = 0;",
          "context": "blockItem",
          "title": "<p>declare a variable</p>\n<p>Declare a variable of type <code>type</code> and name <code>variable</code> with an\ninitial value of <code>0</code>.</p>\n"
        },
        {
          "block": "type *pointer = NULL;",
          "context": "blockItem",
          "title": "<p>declare a pointer</p>\n<p>Declare pointer to a a variable of type <code>type</code> and name <code>v</code> with an\ninitial value of <code>NULL</code>. Hint: a string is <code>char*</     code>.</p>\n"
        },
        {
          "block": "type array[length] = {0};",
          "context": "blockItem",
          "title": "<p>declare an array</p>\n<p>Declare an array of type <code>type</code> and size <code>len</code> with name <code>v</code>. Arrays and pointers work much the same, except that arrays do not    need to be allocated first, because they are automatically allocated when they are declared.</p>"
        },
        {
          "block": "variable = value;",
          "context": "blockItem",
          "title": "<p>reassign a variable</p>\n<p>Assign a new value <code>value</code> to the variable with name <code>variable</code>. You must\ndeclare your variable before you can do this.</p>\n"
        },
        {
          "block": "typedef struct\n{\n  type member;\n}\nname;",
          "context": "externalDeclaration",
          "title": "<p><code>struct</code> -- bundle together data</p>\n<p>A <code>struct</code> defines a package of data made up of a set of data fields. Each data field should be declared in the <code>{ }</   code> like a variable."
        },
        {
          "block": "struct_name.member_name",
          "context": "expression",
          "title": "<p>struct property access</p>\n<p>Extract one of the data fields packaged into a struct.</p>\n"
        },
        {
          "block": "type member;",
          "context": "structDeclaration",
          "title": "<p>declare struct data field</p>"
        }
      ]
    },
    {
      "name": "Functions",
      "color": "blue",
      "blocks": [
        {
          "block": "int main(void)\n{\n  \n}",
          "context": "externalDeclaration",
          "title": "<p><code>main</code> -- starting point for the program</p>\n<p>The <code>main</code> method. Code inside here <code>{ }</code>\nwill run when your program is run. You must\ninclude a main     method in order for your program executable\nto do anything when run.</p>\n"
        },
        {
          "block": "int main(int n, char *argv[])\n{\n  \n}",
          "context": "externalDeclaration",
          "title": "<p><code>main</code> -- starting point for the program</p>\n<p>The <code>main</code> method. Code inside here <code>{ }</code>\nwill run when your program is run. You must\ninclude a main     method in order for your program executable\nto do anything when run. This version knows how to accept command line arguments; there are <code>n</code> of them, stored in the variable <code>args</code>.</p>\n"
        },
        {
          "block": "type function(void)\n{\n  \n}",
          "context": "externalDeclaration",
          "title": "<p>method -- reusable procedure</p>\n<p>Defines a method accepting a <code>void</code> (no arguments) and returning\na <code>type</code>. The code inside <code>{ }</code> will not run at      first, but will run every time\nyou call <code>function(arguments...)</code>. Use a <code>return</code> statement inside the method\nto pass information back to whoever called it.</p>\n"
        },
        {
          "block": "function(argument);",
          "context": "blockItem",
          "title": "<p>A method call.</p>\n"
        },
        {
          "block": "eprintf(format);",
          "context": "blockItem",
          "title": "eprintf"
        },
        {
          "block": "get_char();",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/cs50.h/get_char\" target=\"_blank\">get_char</a> - returns a char from stdin</p>\n<p>Reads a line of text from standard input and returns the equivalent <code>char</code>; if text does not represent a <code>char</code>, user is \nprompted to retry. Leading and trailing whitespace is ignored. If line can&#39;t be read, returns <code>CHAR_MAX</code>.</p>\n"
        },
        {
          "block": "get_double();",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/cs50.h/get_double\" target=\"_blank\">get_double</a> - returns a double from stdin</p>\n<p>Reads a line of text from standard input and returns the equivalent <code>double</code> as precisely as possible; if text does not \nrepresent a <code>double</code>, user is prompted to retry. Leading and trailing whitespace is ignored. For simplicity, overflow \nand underflow are not detected. If line can&#39;t be read, returns <code>DBL_MAX</code>.</p>\n"
        },
        {
          "block": "get_float();",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/cs50.h/get_float\" target=\"_blank\">get_float</a> - returns a float from stdin</p>\n<p>Reads a line of text from standard input and returns the equivalent <code>float</code> as precisely as possible; if text does not \nrepresent a <code>float</code>, user is prompted to retry. Leading and trailing whitespace is ignored. For simplicity, overflow \nand underflow are not detected.  If line can&#39;t be read, returns <code>FLT_MAX</code>.</p>\n"
        },
        {
          "block": "get_int();",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/cs50.h/get_int\" target=\"_blank\">get_int</a> - returns an int from stdin</p>\n<p>Reads a line of text from standard input and returns it as an <code>int</code> in the range of [-2^31^ + 1, 2^31^ - 2], if possible; \nif text does not represent such an <code>int</code>, user is prompted to retry. Leading and trailing whitespace is ignored. For \nsimplicity, overflow is not detected. If line can&#39;t be read, returns <code>INT_MAX</code>.</p>\n"
        },
        {
          "block": "get_long_long();",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/cs50.h/get_long_long\" target=\"_blank\">get_long_long</a> - returns a long long from stdin</p>\n<p>Reads a line of text from standard input and returns an equivalent <code>long long</code> in the range [-2^63^ + 1, 2^63^ - 2], if \npossible; if text does not represent such a <code>long long</code>, user is prompted to retry. Leading and trailing whitespace is \nignored. For simplicity, overflow is not detected. If line can&#39;t be read, returns <code>LLONG_MAX</code>.</p>\n"
        },
        {
          "block": "get_string();",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/cs50.h/get_string\" target=\"_blank\">get_string</a> - returns a string from stdin</p>\n<p>Reads a line of text from standard input and returns it as a <code>string</code> (<code>char *</code>), sans trailing newline character. (Ergo, \nif user inputs only <code>&quot;\\n&quot;</code>, returns &quot;&quot; not <code>NULL</code>.)  Returns <code>NULL</code> upon error or no input whatsoever (i.e., just <code>EOF</code>). \nLeading and trailing whitespace is not ignored. Stores <code>string</code> on heap (via <code>malloc</code>); memory must be freed by caller to \navoid leak.</p>\n"
        },
        {
          "block": "calloc(length, sizeof(type))",
          "context": "expression",
          "title": "<p><a href=\"https://reference.cs50.net/stdlib.h/calloc\" target=\"_blank\">calloc</a> - allocate memory and set it to zero</p>\n<p><code>calloc</code> allocates the requested memory and sets it all to zero. So, it will\nallocate  <code>size</code> bytes <code>items</code> number of times. For example, if <code>size</code> is\n4 bytes, and <code>items</code> 10, then <code>calloc</code> will allocate a total of 40 bytes. \nThis differs from <code>malloc</code> which doesn&#39;t set the memory to zero.</p>\n"
        },
        {
          "block": "malloc(size)",
          "context": "expression",
          "title": "<p><a href=\"https://reference.cs50.net/stdlib.h/malloc\" target=\"_blank\">malloc</a> - allocate memory</p>\n<p>Allocate <code>size</code> bytes of memory. Unlike <code>calloc</code>, <code>malloc</code> will not pre-set all\nallocated memory to zero.</p>\n"
        },
        {
          "block": "printf(format);",
          "context": "blockItem",
          "title": "<p><a href=\"https://reference.cs50.net/stdio.h/printf\" target=\"_blank\">printf</a> - prints to stdout</p>\n<p><code>printf</code> prints some formatted output to <code>stdout</code> (your computer terminal).\nYou specify the format with a <code>%</code> followed by a <code>c</code> for a character, <code>d</code> for\na digit, and <code>s</code> for a string. There are a number of other identifiers, the\naformentioned, however, are the most used. (<a href=\"https://reference.cs50.net/stdio.h/printf\" target=\"_blank\">read more</a>)</p>\n"
        }
      ]
    },
    {
      "name": "Preprocessor",
      "color": "purple",
      "blocks": [
        {
          "block": "#include <header.h>",
          "context": "compilationUnit",
          "title": "<p><code>#include</code> -- include library files</p>\n<p>Put this at the top of your program to include the necessary files to use a library. Examples: <code>#include &lt;stdio.h&gt;</code> or <code>#include &lt;cs50.h&gt;</code></p>"
        },
        {
          "block": "#define MACRO_NAME macro_value",
          "context": "compilationUnit",
          "title": "<p><code>#define</code> -- define a macro</p>\n<p>Put this at the top of your program to define a macro. The compiler will go through your program and replace all instances of <code>MACRO_NAME</code> with the value. Most often, this is used for defining constants.</p>"
        }
      ]
    },
    {
      "name": "Comments",
      "color": "grey",
      "blocks": [
        {
          "block": "// comment",
          "context": "compilationUnit",
          "title": "<p>comment</p>\n<p>Add some text to explain part of your code. This block can go anywhere.</p>"
        }
      ]
    }
  ],
  "modeOptions": {
    "functions": {
      "get_char": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "get_char();"
      },
      "get_double": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "get_double();"
      },
      "get_float": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "get_float();"
      },
      "get_int": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "get_int();"
      },
      "get_long_long": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "get_long_long();"
      },
      "get_string": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "get_string();"
      },
      "clearerr": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "clearerr(stream);"
      },
      "fclose": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fclose(fp);"
      },
      "feof": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "feof(fp);"
      },
      "ferror": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "ferror(stream);"
      },
      "fflush": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fflush(stream);"
      },
      "fgetc": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fgetc(fp);"
      },
      "fgetpos": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fgetpos(stream, pos);"
      },
      "fgets": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fgets(s, i, fp);"
      },
      "fopen": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fopen(filename, mode);"
      },
      "fprintf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fprintf(fp, format);",
        "minArgs": 2
      },
      "fputc": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fputc(character, fp);"
      },
      "fputs": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fputs(s, fp);"
      },
      "fread": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fread(ptr, size, blocks, fp);"
      },
      "fscanf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fscanf(fp, format);",
        "minArgs": 2
      },
      "fseek": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fseek(fp, offset, from_where);"
      },
      "fsetpos": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fsetpos(stream, pos);"
      },
      "ftell": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "ftell(stream);"
      },
      "fwrite": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fwrite(ptr, size, blocks, fp);"
      },
      "getc": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "getc(stream);"
      },
      "getchar": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "getchar();"
      },
      "gets": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "gets(s);"
      },
      "perror": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "perror(s);"
      },
      "printf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "printf(format);",
        "minArgs": 1
      },
      "eprintf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "eprintf(format);",
        "minArgs": 1
      },
      "putc": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "putc(c, stream);"
      },
      "putchar": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "putchar(c);"
      },
      "puts": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "puts(s);"
      },
      "remove": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "remove(pathname);"
      },
      "rewind": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "rewind(stream);"
      },
      "scanf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "scanf(format);",
        "minArgs": 1
      },
      "setbuf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "setbuf(stream, buf);"
      },
      "setvbuf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "setvbuf(stream, buf, mode, size);"
      },
      "snprintf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "snprintf(str, size, format);",
        "minArgs": 3
      },
      "sprintf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "sprintf(ptr, format);",
        "minArgs": 2
      },
      "sscanf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "sscanf(str, format);",
        "minArgs": 2
      },
      "ungetc": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "ungetc(c, stream);"
      },
      "vfprintf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "vfprintf(stream, format, ap);"
      },
      "vfscanf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "vfscanf(stream, format, ap);"
      },
      "vprintf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "vprintf(format, ap);"
      },
      "vscanf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "vscanf(format, ap);"
      },
      "vsnprintf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "vsnprintf(str, size, format, ap);"
      },
      "vsprintf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "vsprintf(str, format, ap);"
      },
      "vsscanf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "vsscanf(str, format, ap);"
      },
      "abort": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "abort();"
      },
      "abs": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "abs(j);"
      },
      "atexit": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "atexit(function);"
      },
      "atof": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "atof(nptr);"
      },
      "atoi": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "atoi(str);"
      },
      "atol": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "atol(nptr);"
      },
      "atoll": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "atoll(nptr);"
      },
      "bsearch": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "bsearch(key, base, nmemb, size, compar);"
      },
      "calloc": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "calloc(items, size);"
      },
      "div": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "div(numerator, denominator);"
      },
      "drand48": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "drand48();"
      },
      "exit": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "exit(status);"
      },
      "free": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "free(ptr);"
      },
      "getenv": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "getenv(name);"
      },
      "labs": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "labs(j);"
      },
      "ldiv": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "ldiv(numerator, denominator);"
      },
      "llabs": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "llabs(j);"
      },
      "lldiv": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "lldiv(numerator, denominator);"
      },
      "malloc": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "malloc(size);"
      },
      "mblen": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "mblen(s, n);"
      },
      "mbstowcs": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "mbstowcs(dest, src, n);"
      },
      "mbtowc": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "mbtowc(pwc, s, n);"
      },
      "qsort": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "qsort(base, nmemb, size, compar);"
      },
      "rand": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "rand();"
      },
      "realloc": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "realloc(ptr, size);"
      },
      "srand": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "srand(seed);"
      },
      "srand48": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "srand48(seedval);"
      },
      "strtod": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strtod(nptr, endptr);"
      },
      "strtof": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strtof(nptr, endptr);"
      },
      "strtol": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strtol(nptr, endptr, base);"
      },
      "strtold": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strtold(nptr, endptr);"
      },
      "strtoll": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strtoll(nptr, endptr, base);"
      },
      "strtoul": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strtoul(nptr, endptr, base);"
      },
      "strtoull": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strtoull(nptr, endptr, base);"
      },
      "system": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "system(command);"
      },
      "wcstombs": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "wcstombs(dest, src, n);"
      },
      "wctomb": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "wctomb(s, wc);"
      },
      "memchr": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "memchr(s, c, n);"
      },
      "memcmp": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "memcmp(s1, s2, n);"
      },
      "memcpy": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "memcpy(dest, src, n);"
      },
      "memmove": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "memmove(dest, src, n);"
      },
      "memset": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "memset(s, c, n);"
      },
      "strcat": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strcat(dest, src);"
      },
      "strchr": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strchr(s, c);"
      },
      "strcmp": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strcmp(str1, str2);"
      },
      "strcoll": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strcoll(s1, s2);"
      },
      "strcpy": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strcpy(destination, source);"
      },
      "strcspn": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strcspn(s, reject);"
      },
      "strerror": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strerror(errnum);"
      },
      "strlen": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strlen(str);"
      },
      "strncat": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strncat(dest, src, n);"
      },
      "strncmp": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strncmp(s1, s2, n);"
      },
      "strncpy": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strncpy(dest, src, n);"
      },
      "strpbrk": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strpbrk(s, accept);"
      },
      "strrchr": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strrchr(s, c);"
      },
      "strspn": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strspn(s, accept);"
      },
      "strstr": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strstr(haystack, needle);"
      },
      "strtok": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strtok(str, delim);"
      },
      "strxfrm": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strxfrm(dest, src, n);"
      },
      "acos": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "acos(x);"
      },
      "acosh": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "acosh(x);"
      },
      "asin": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "asin(x);"
      },
      "asinh": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "asinh(x);"
      },
      "atan": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "atan(x);"
      },
      "atan2": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "atan2(y, x);"
      },
      "atanh": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "atanh(x);"
      },
      "ceil": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "ceil(x);"
      },
      "copysign": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "copysign(x, y);"
      },
      "cos": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "cos(x);"
      },
      "cosh": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "cosh(x);"
      },
      "erf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "erf(x);"
      },
      "erfc": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "erfc(x);"
      },
      "exp": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "exp(x);"
      },
      "exp2": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "exp2(x);"
      },
      "expm1": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "expm1(x);"
      },
      "fabs": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fabs(x);"
      },
      "fdim": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fdim(x, y);"
      },
      "floor": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "floor(x);"
      },
      "fma": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fma(x, y, z);"
      },
      "fmax": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fmax(x, y);"
      },
      "fmin": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fmin(x, y);"
      },
      "fmod": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fmod(x, y);"
      },
      "fpclassify": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "fpclassify(x);"
      },
      "frexp": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "frexp(x, exp);"
      },
      "ilogb": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "ilogb(x);"
      },
      "isfinite": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isfinite(x);"
      },
      "isgreater": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isgreater(x, y);"
      },
      "isgreaterequal": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isgreaterequal(x, y);"
      },
      "isinf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isinf(x);"
      },
      "isless": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isless(x, y);"
      },
      "islessequal": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "islessequal(x, y);"
      },
      "islessgreater": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "islessgreater(x, y);"
      },
      "isnan": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isnan(x);"
      },
      "isnormal": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isnormal(x);"
      },
      "isunordered": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isunordered(x, y);"
      },
      "ldexp": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "ldexp(x, exp);"
      },
      "llrint": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "llrint(x);"
      },
      "llround": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "llround(x);"
      },
      "log": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "log(x);"
      },
      "log10": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "log10(x);"
      },
      "log1p": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "log1p(x);"
      },
      "log2": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "log2(x);"
      },
      "logb": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "logb(x);"
      },
      "lrint": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "lrint(x);"
      },
      "lround": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "lround(x);"
      },
      "modf": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "modf(x, iptr);"
      },
      "nearbyint": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "nearbyint(x);"
      },
      "pow": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "pow(x, y);"
      },
      "remainder": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "remainder(x, y);"
      },
      "remquo": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "remquo(x, y, quo);"
      },
      "rint": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "rint(x);"
      },
      "round": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "round(x);"
      },
      "scalbln": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "scalbln(x, exp);"
      },
      "scalbn": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "scalbn(x, exp);"
      },
      "signbit": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "signbit(x);"
      },
      "sin": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "sin(x);"
      },
      "sinh": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "sinh(x);"
      },
      "sqrt": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "sqrt(x);"
      },
      "tan": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "tan(x);"
      },
      "tgamma": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "tgamma(x);"
      },
      "trunc": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "trunc(x);"
      },
      "asctime": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "asctime(tm);"
      },
      "clock": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "clock();"
      },
      "ctime": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "ctime(timep);"
      },
      "difftime": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "difftime(time1, time0);"
      },
      "mktime": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "mktime(tm);"
      },
      "strftime": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "strftime(s, max, format, tm);"
      },
      "time": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "time(tloc);"
      },
      "isalnum": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isalnum(c);"
      },
      "isalpha": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isalpha(c);"
      },
      "isblank": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isblank(c);"
      },
      "iscntrl": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "iscntrl(c);"
      },
      "isdigit": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isdigit(c);"
      },
      "isgraph": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isgraph(c);"
      },
      "islower": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "islower(c);"
      },
      "isprint": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isprint(c);"
      },
      "ispunct": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "ispunct(c);"
      },
      "isspace": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isspace(c);"
      },
      "isupper": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isupper(c);"
      },
      "isxdigit": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "isxdigit(c);"
      },
      "tolower": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "tolower(c);"
      },
      "toupper": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "toupper(c);"
      },
      "va_arg": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "va_arg(ap, type);"
      },
      "va_copy": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "va_copy(dest, src);"
      },
      "va_end": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "va_end(ap);"
      },
      "va_start": {
        "color": "blue",
        "shape": "block-only",
        "prototype": "va_start(ap, last);"
      }
    }
  }
}
